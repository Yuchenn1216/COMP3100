import java.io.*;
import java.net.*;

public class DSclient {
    public static void main(String[] args) {
        try {
            // Create a socket
            Socket s = new Socket("localhost", 50000);
            // Initialize input and output streams associated with the socket
            DataOutputStream out = new DataOutputStream(s.getOutputStream());
            BufferedReader in = new BufferedReader(new InputStreamReader(s.getInputStream()));

            // Connect to ds-server
            // Send HELO
            out.write(("HELO\n").getBytes());
            out.flush();
            String str = (String) in.readLine();

            // Send AUTH username
            String username = System.getProperty("user.name");
            out.write(("AUTH " + username + "\n").getBytes());
            out.flush();
            str = (String) in.readLine();

            while (true) {
                out.write(("REDY\n").getBytes());
                out.flush();
                str = in.readLine();
                
                // If the jobType is NONE, indicating no more jobs, so quit the while loop
                if (str.equals("NONE"))
                    break;
                
                // Store the type of job and its ID
                String[] jobInfo = str.split(" ");
                String jobType = jobInfo[0];
                String jobID = jobInfo[2];

                // If JCPL, continue
                if (jobType.equals("JCPL"))
                    continue;

                // Request server information
                out.write(("GETS All\n").getBytes());
                out.flush();
                str = (String) in.readLine();
                out.write(("OK\n").getBytes());
                out.flush();

                String[] serverInfoList = str.split(" ");
                int nRecs = Integer.parseInt(serverInfoList[1]);

                String selectedServer = "";
                int minTurnaroundTime = Integer.MAX_VALUE;
                int minRentalCost = Integer.MAX_VALUE;

                for (int i = 0; i < nRecs; i++) {
                    str = (String) in.readLine();
                    String[] serverInfo = str.split(" ");
                    String serverType = serverInfo[0];
                    int coreNum = Integer.parseInt(serverInfo[4]);

                    // Check if the server has sufficient resources for the job
                    if (coreNum >= jobCoreRequirement) {
                        int runningJobs = Integer.parseInt(serverInfo[2]);
                        int waitingJobs = Integer.parseInt(serverInfo[3]);

                        // If there are no running jobs and waiting jobs, schedule the job
                        if (runningJobs == 0 && waitingJobs == 0) {
                            selectedServer = serverType;
                            break;
                        }

                        // Calculate the expected turnaround time and rental cost
                        int turnaroundTime = calculateTurnaroundTime(jobID, serverType, runningJobs, waitingJobs);
                        int rentalCost = calculateRentalCost(jobID, serverType);

                        // Update the selected server if it offers better turnaround time and rental cost
                        if (turnaroundTime < minTurnaroundTime || (turnaroundTime == minTurnaroundTime && rentalCost < minRentalCost)) {
                            selectedServer = serverType;
                            minTurnaroundTime = turnaroundTime;
                            minRentalCost = rentalCost;
                        }
                    }
                }

                // Schedule the job to the selected server
                String schdMsg = "SCHD " + jobID + " " + selectedServer + " " + 0 + "\n";
                out.write(schdMsg.getBytes());
                out.flush();
                str = in.readLine();
            }

            // Quit simulation gracefully
            out.write(("QUIT\n").getBytes());
            out.flush();
            str = in.readLine();

            // Close streams and socket
            in.close();
            out.close();
            s.close();
        } catch (Exception e) {
            System.out.println(e);
        }
    }

    // Calculate the expected turnaround time for the job on the server
    private static int calculateTurnaroundTime(String jobID, String serverType, int runningJobs, int waitingJobs) {

    }

    // Calculate the rental cost for the job on the server
    private static int calculateRentalCost(String jobID, String serverType) {
    
    }
}
